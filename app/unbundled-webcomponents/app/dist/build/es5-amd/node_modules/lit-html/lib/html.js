define(["exports","./template.js"],function(_exports,_template){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.HTMLTemplate=void 0;var markerRegex=/{{(.*?)}}/,HTMLTemplate=function HTMLTemplate(element){babelHelpers.classCallCheck(this,HTMLTemplate);this.parts=[];this.element=element;var index=-1,partIndex=0,nodesToRemove=[],walker=document.createTreeWalker(element.content,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_TEXT);while(walker.nextNode()){index++;var node=walker.currentNode;if(1===node.nodeType/* Node.ELEMENT_NODE */){if(node.hasAttributes()){for(var attributes=Array.from(node.attributes),i=0;i<attributes.length;i++){var attr=attributes[i],result=attr.value.split(markerRegex);console.log("result",result);var attributeStrings=result.filter(function(_,i){return 0===i%2});// const exprStrings = result.filter((_, i) => i % 2 === 1);
console.log("attributeStrings",attributeStrings);if(0<attributeStrings.length){this.parts.push({type:"attribute",index:index,name:name,strings:attributeStrings});node.removeAttribute(attr.name);partIndex+=attributeStrings.length-1}}}}else if(3===node.nodeType/* Node.TEXT_NODE */){var data=node.data,parent=node.parentNode,_result=data.split(markerRegex),strings=_result.filter(function(_,i){return 0===i%2});if(0<strings.length){// Generate a new text node for each literal section
// These nodes are also used as the markers for node parts
for(var lastIndex=strings.length-1,_i=0;_i<lastIndex;_i++){parent.insertBefore(""===strings[_i]?(0,_template.createMarker)():document.createTextNode(strings[_i]),node);this.parts.push({type:"node",index:++index})}// If there's no text, we must insert a comment to mark our place.
// Else, we can trust it will stick around after cloning.
if(""===strings[lastIndex]){parent.insertBefore((0,_template.createMarker)(),node);nodesToRemove.push(node)}else{node.data=strings[lastIndex]}// We have a part for each match found
partIndex+=lastIndex}}}};_exports.HTMLTemplate=HTMLTemplate});