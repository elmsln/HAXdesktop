define(["exports"],function(_exports){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.pathResolver=pathResolver;_exports.pathFromUrl=pathFromUrl;_exports.SimpleIconsetStore=_exports.SimpleIconset=void 0;function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable});keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var i=1,source;i<arguments.length;i++){source=null!=arguments[i]?arguments[i]:{};if(i%2){ownKeys(Object(source),!0).forEach(function(key){babelHelpers.defineProperty(target,key,source[key])})}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source))}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))})}}return target}/**
 * Singleton to manage iconsets
 * @demo demo/index.html
 */ // polyfill for replaceAll, I hate you Safari / really old stuff
if(!String.prototype.replaceAll){String.prototype.replaceAll=function(find,replace){return this.split(find).join(replace)}}var SimpleIconset=/*#__PURE__*/function(_HTMLElement){babelHelpers.inherits(SimpleIconset,_HTMLElement);babelHelpers.createClass(SimpleIconset,null,[{key:"tag",get:function get(){return"simple-iconset"}}]);function SimpleIconset(){var _this;babelHelpers.classCallCheck(this,SimpleIconset);_this=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(SimpleIconset).call(this));_this.iconsets={};_this.needsHydrated=[];return _this}/**
   * Iconsets are to register a namespace in either manner:
   * object notation: key name of the icon with a specific path to the file
   * {
   *   icon: iconLocation,
   *   icon2: iconLocation2
   * }
   * string notation: assumes icon name can be found at ${iconLocationBasePath}${iconname}.svg
   * iconLocationBasePath
   */babelHelpers.createClass(SimpleIconset,[{key:"registerIconset",value:function registerIconset(name){var _this2=this,icons=1<arguments.length&&arguments[1]!==void 0?arguments[1]:{};if("object"===babelHelpers.typeof(icons)){this.iconsets[name]=_objectSpread({},icons)}else if("string"===typeof icons){this.iconsets[name]=icons}// try processing anything that might have missed previously
if(0<this.needsHydrated.length){var list=[];this.needsHydrated.forEach(function(item,index){// set the src from interns of the icon, returns if it matched
// which will then push it into the list to be removed from processing
if(item.setSrcByIcon(_this2)){list.push(index)}});// process in reverse order to avoid key splicing issues
list.reverse().forEach(function(val){_this2.needsHydrated.splice(val,1)})}}/**
   * return the icon location on splitting the string on : for position in the object
   * if the icon doesn't exist, it sets a value for future updates in the event
   * that the library for the icon registers AFTER the request to visualize is made
   */},{key:"getIcon",value:function getIcon(val,context){var ary=val.replaceAll("/","-").split(":");// legacy API used to fill in icons: for lazy devs so let's mirror
if(1===ary.length){ary=["icons",val]}if(2==ary.length&&this.iconsets[ary[0]]){if("string"!==typeof this.iconsets[ary[0]]&&this.iconsets[ary[0]][ary[1]]&&"function"!==typeof this.iconsets[ary[0]][ary[1]]){return this.iconsets[ary[0]][ary[1]]}else if(ary[1]){return"".concat(this.iconsets[ary[0]]).concat(ary[1],".svg")}}// if we get here we just missed on the icon hydrating which means
// either it's an invalid icon OR the library to register the icons
// location will import AFTER (possible microtiming early on)
// also weird looking by context is either the element asking about
// itself OR the the iconset state manager checking for hydration
if(context!=this){this.needsHydrated.push(context)}return null}}]);return SimpleIconset}(/*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));/**
 * helper function for iconset developers to resolve relative paths
 */_exports.SimpleIconset=SimpleIconset;function pathResolver(base){var path=1<arguments.length&&arguments[1]!==void 0?arguments[1]:"";return pathFromUrl(decodeURIComponent(base))+path}// simple path from url
function pathFromUrl(url){return url.substring(0,url.lastIndexOf("/")+1)}customElements.define(SimpleIconset.tag,SimpleIconset);window.SimpleIconset=window.SimpleIconset||{};/**
 * Checks to see if there is an instance available, and if not appends one
 */window.SimpleIconset.requestAvailability=function(){if(null==window.SimpleIconset.instance){window.SimpleIconset.instance=document.createElement("simple-iconset")}document.body.appendChild(window.SimpleIconset.instance);return window.SimpleIconset.instance};// self request so that when this file is referenced it exists in the dom
var SimpleIconsetStore=window.SimpleIconset.requestAvailability();_exports.SimpleIconsetStore=SimpleIconsetStore});