define(["exports","../../../lit-element/lit-element.js","../../utils/utils.js","./hax-store.js","../../../@vaadin/vaadin-upload/vaadin-upload.js"],function(_exports,_litElement,_utils,_haxStore,_vaadinUpload){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.HaxTrayUpload=void 0;function _templateObject2_d9d69b00812711eb9b3b3bc8a337bd59(){var data=babelHelpers.taggedTemplateLiteral(["\n      <input type=\"text\" id=\"url\" hidden />\n      <vaadin-upload\n        @upload-before=\"","\"\n        @upload-response=\"","\"\n        form-data-name=\"file-upload\"\n        id=\"fileupload\"\n      ></vaadin-upload>\n    "]);_templateObject2_d9d69b00812711eb9b3b3bc8a337bd59=function _templateObject2_d9d69b00812711eb9b3b3bc8a337bd59(){return data};return data}function _templateObject_d9d69b00812711eb9b3b3bc8a337bd59(){var data=babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n        }\n        input[hidden] {\n          display: none;\n        }\n        vaadin-upload::part(file-list) {\n          display: none;\n        }\n      "]);_templateObject_d9d69b00812711eb9b3b3bc8a337bd59=function _templateObject_d9d69b00812711eb9b3b3bc8a337bd59(){return data};return data}var HaxTrayUpload=/*#__PURE__*/function(_winEventsElement){babelHelpers.inherits(HaxTrayUpload,_winEventsElement);babelHelpers.createClass(HaxTrayUpload,null,[{key:"styles",get:function get(){return[(0,_litElement.css)(_templateObject_d9d69b00812711eb9b3b3bc8a337bd59())]}/**
   * Convention we use
   */},{key:"tag",get:function get(){return"hax-tray-upload"}/**
   * HTMLElement
   */}]);function HaxTrayUpload(){var _this;babelHelpers.classCallCheck(this,HaxTrayUpload);_this=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(HaxTrayUpload).call(this));_this.__winEvents={"hax-app-picker-selection":"_haxAppPickerSelection","place-holder-file-drop":"_placeHolderFileDrop"};return _this}/**
   * LitElement render
   */babelHelpers.createClass(HaxTrayUpload,[{key:"render",value:function render(){return(0,_litElement.html)(_templateObject2_d9d69b00812711eb9b3b3bc8a337bd59(),this._fileAboutToUpload,this._fileUploadResponse)}/**
   * Configure asset after upload or URL passed in.
   */},{key:"newAssetConfigure",value:function newAssetConfigure(){var values={source:this.shadowRoot.querySelector("#url").value,title:this.shadowRoot.querySelector("#url").value};_haxStore.HAXStore.insertLogicFromValues(values,this)}/**
   * A file event was detected from a drag and drop in the interface, most likely
   * from a place-holder tag
   */},{key:"_placeHolderFileDrop",value:function _placeHolderFileDrop(e){// reference the active place holder element since place holders are
// the only things possible for seeing these
_haxStore.HAXStore.activePlaceHolder=e.detail.placeHolderElement;// ! I can't believe this actually works. This takes the event
// ! that was a drop event else where on the page and then repoints
// ! it to simulate the drop event using the same event structure that
// ! would have happened if they had used this element in the first place
this.shadowRoot.querySelector("#fileupload")._onDrop(e.detail)}/**
   * Respond to successful file upload, now inject url into url field and
   * do a gizmo guess from there!
   */},{key:"_fileUploadResponse",value:function _fileUploadResponse(e){this.editExistingNode=!0;// convert response to object
var response=JSON.parse(e.detail.xhr.response),map=this.__appUsed.connection.operations.add.resultMap,data={},item={};// access the app that did the upload
// look for the items element to draw our data from at its root
if(babelHelpers.typeof(this._resolveObjectPath(map.item,response))!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){data=this._resolveObjectPath(map.item,response)}item.type=map.defaultGizmoType;// pull in prop matches
for(var prop in map.gizmo){item[prop]=this._resolveObjectPath(map.gizmo[prop],data)}// another sanity check, if we don't have a url but have a source bind that too
if(babelHelpers.typeof(item.url)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&babelHelpers.typeof(item.source)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){item.url=item.source}// gizmo type is also supported in the mapping element itself
// Think an asset management backend as opposed to a specific
// type of asset like video. If the item coming across can
// effectively check what kind of gizmo is required for it
// to work then we need to support that asset declaring the
// gizmo type needed
if(babelHelpers.typeof(map.gizmo.type)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){item.type=this._resolveObjectPath(map.gizmo.type,data)}this.shadowRoot.querySelector("#url").value=item.url;// @todo put in logic to support the response actually
// just outright returning a haxElement. This is rare
// but if the HAX developer has control over the endpoint
// then they could get HAX to streamline some workflows
// or by-pass the gizmo selection step to improve UX
// for end users even further. Examples could be a media
// management system that has remote rendering (cms-token)
// or a highly specific endpoint that we know we can only
// present in one way effectively Box / Google doc viewer.
this.newAssetConfigure()}/**
   * Respond to uploading a file
   */},{key:"_fileAboutToUpload",value:function _fileAboutToUpload(e){if(!this.__allowUpload){// cancel the event so we can jump in
e.preventDefault();e.stopPropagation();// look for a match as to what gizmo types it supports
var values={source:e.detail.file.name,type:e.detail.file.type},type=_haxStore.HAXStore.guessGizmoType(values),targets=_haxStore.HAXStore.getHaxAppStoreTargets(type);// we have no clue what this is.. let's try and guess..
// make sure we have targets
if(1===targets.length){this._haxAppPickerSelection({detail:targets[0]})}else if(0!==targets.length){_haxStore.HAXStore.haxAppPicker.presentOptions(targets,type,"Where would you like to upload this "+type+"?","app")}else{_haxStore.HAXStore.toast("Sorry, you don't have a storage location that can handle "+type+" uploads!",5e3)}}else{this.__allowUpload=!1}}/**
   * Event for an app being selected from a picker
   * This happens when multiple upload targets support the given type
   */},{key:"_haxAppPickerSelection",value:function _haxAppPickerSelection(e){// details for where to upload the file
var connection=e.detail.connection;this.__appUsed=e.detail;this.shadowRoot.querySelector("#fileupload").method=connection.operations.add.method;var requestEndPoint=connection.protocol+"://"+connection.url;// ensure we build a url correctly
if("/"!=requestEndPoint.substr(requestEndPoint.length-1)){requestEndPoint+="/"}// support local end point modification
if(babelHelpers.typeof(connection.operations.add.endPoint)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){requestEndPoint+=connection.operations.add.endPoint}// implementation specific tweaks to talk to things like HAXcms and other CMSs
// that have per load token based authentication
if(null!=_haxStore.HAXStore.connectionRewrites.appendUploadEndPoint){requestEndPoint+="?"+_haxStore.HAXStore.connectionRewrites.appendUploadEndPoint}if(null!=_haxStore.HAXStore.connectionRewrites.appendJwt){requestEndPoint+="&"+_haxStore.HAXStore.connectionRewrites.appendJwt+"="+localStorage.getItem(_haxStore.HAXStore.connectionRewrites.appendJwt)}this.shadowRoot.querySelector("#fileupload").headers=connection.headers;this.shadowRoot.querySelector("#fileupload").target=requestEndPoint;// invoke file uploading...
this.__allowUpload=!0;this.shadowRoot.querySelector("#fileupload").uploadFiles()}/**
   * Helper to take a multi-dimensional object and convert
   * it's reference into the real value. This allows for variable input defined
   * in a string to actually hit the deeper part of an object structure.
   */},{key:"_resolveObjectPath",value:function _resolveObjectPath(path,obj){return path.split(".").reduce(function(prev,curr){return prev?prev[curr]:null},obj||self)}}]);return HaxTrayUpload}((0,_utils.winEventsElement)(_litElement.LitElement));_exports.HaxTrayUpload=HaxTrayUpload;window.customElements.define(HaxTrayUpload.tag,HaxTrayUpload)});