define(["exports","../../lit-element/lit-element.js"],function(_exports,_litElement){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.UndoManagerBehaviors=_exports.UndoManagerCommand=_exports.Undo=_exports.UndoManager=void 0;function _templateObject_0861ca30812d11eb9c332bb120816628(){var data=babelHelpers.taggedTemplateLiteral(["<slot></slot>"]);_templateObject_0861ca30812d11eb9c332bb120816628=function _templateObject_0861ca30812d11eb9c332bb120816628(){return data};return data}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable});keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var i=1,source;i<arguments.length;i++){source=null!=arguments[i]?arguments[i]:{};if(i%2){ownKeys(Object(source),!0).forEach(function(key){babelHelpers.defineProperty(target,key,source[key])})}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source))}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))})}}return target}/**
 * `undo-manager`
 * `an undo history manager element`
 *  This brings ideas from https://addyosmani.com/blog/mutation-observers/
 *  back to life and this time as LitElement + with the web drastically
 *  moved forward vs when this was originally published (2014).
 *
 * @element undo-manager
 * @demo demo/index.html
 */var UndoManagerBehaviors=function UndoManagerBehaviors(SuperClass){return(/*#__PURE__*/function(_SuperClass){babelHelpers.inherits(_class,_SuperClass);babelHelpers.createClass(_class,null,[{key:"properties",/**
     * LitElement / popular convention
     */get:function get(){return _objectSpread({},babelHelpers.get(babelHelpers.getPrototypeOf(_class),"properties",this),{/**
         * If we can currently undo based on stack position
         */canUndo:{type:Boolean,attribute:"can-undo"},/**
         * If we can currently redo based on stack position
         */canRedo:{type:Boolean,attribute:"can-redo"},/**
         * Properties for the mutation observer
         */undoStackObserverProps:{type:Object},/**
         * Allow for targetting OTHER elements w/ this behavior
         */target:{type:Object},/**
         * The undo stack order
         */stack:{type:Object}})}/**
     * HTMLElement
     */}]);function _class(){var _this;babelHelpers.classCallCheck(this,_class);_this=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(_class).call(this));_this.__StackDebounce;_this.undoStackLimit=20;_this.undoStackTimer=300;_this.undoStackIgnore=!1;_this.undoStackObserver=null;// this is aggressive but it should capture everything
_this.undoStackObserverProps={attributes:!0,attributeOldValue:!0,childList:!0,characterData:!0,characterDataOldValue:!0,subtree:!0};// set beginning value
_this.undoStackInitialValue=_this.innerHTML;// set previous value, to start
_this.undoStackPrevValue=_this.undoStackInitialValue;return _this}/**
     * Simple path resolution from URL
     */babelHelpers.createClass(_class,[{key:"pathFromUrl",value:function pathFromUrl(url){return url.substring(0,url.lastIndexOf("/")+1)}/**
     * HTMLElement
     */},{key:"connectedCallback",value:function connectedCallback(){var _this2=this;// watch for changes to the element itself
this.undoStackObserver=new MutationObserver(function(mutations){clearTimeout(_this2.__StackDebounce);_this2.__StackDebounce=setTimeout(function(){// ensure this was not a change record to perform undo/redo itself!
if(_this2.undoStackIgnore){_this2.undoStackIgnore=!1;return}// run the stack logic
_this2.undoManagerStackLogic(mutations)},_this2.undoStackTimer)});// watch attributes, children and the subtree for changes
this.undoStackObserver.observe(this,this.undoStackObserverProps);this.undoManagerStackLogic({});babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype),"connectedCallback",this).call(this)}/**
     * While a mutation observer, we only respond to there being ANY change
     * not the specfic record. This lets the developer select granularity
     * in what to notice (lots of stuff) yet only push state change
     * if it matches what they care to monitor as far as detail.
     * Default is to monitor every possible useful detail
     */},{key:"undoManagerStackLogic",value:function undoManagerStackLogic(mutations){// compare light dom children to previous value
var newValue=this.innerHTML;if(this.undoStack&&""!=newValue&&newValue!=this.undoStackPrevValue&&this.undoStackInitialValue!=newValue){this.undoStack.execute(new UndoManagerCommand(this,this.undoStackPrevValue,newValue));this.undoStackPrevValue=newValue;// we only notify there WAS a change
this.dispatchEvent(new CustomEvent("stack-changed",{detail:{value:this.undoStack},bubbles:!0,composed:!0}))}}/**
     * HTMLElement
     */},{key:"disconnectedCallback",value:function disconnectedCallback(){if(this.undoStackObserver){this.undoStackObserver.disconnect()}babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype),"disconnectedCallback",this).call(this)}/**
     * LitElement ready
     */},{key:"firstUpdated",value:function firstUpdated(changedProperties){var _this3=this;if(babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype),"firstUpdated",this)){babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype),"firstUpdated",this).call(this,changedProperties)}this.undoStack=new Undo;this.undoStack.undoStackLimit=this.undoStackLimit;this.undoStack.undoStackPosition=-1;this.undoStack.commands=[];// simple hook into being notified of changes to the object
this.undoStack.changed=function(e){_this3.canRedo=_this3.undoStack.canRedo();_this3.canUndo=_this3.undoStack.canUndo()};// execute once just to get these values
this.undoStack.changed()}/**
     * updated / notice property changes
     */},{key:"updated",value:function updated(changedProperties){var _this4=this;if(babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype),"updated",this)){babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype),"updated",this).call(this,changedProperties)}changedProperties.forEach(function(oldValue,propName){if("canUndo"==propName){// notify
_this4.dispatchEvent(new CustomEvent("can-undo-changed",{detail:{value:_this4[propName]},bubbles:!0,composed:!0}))}if("canRedo"==propName){// notify
_this4.dispatchEvent(new CustomEvent("can-redo-changed",{detail:{value:_this4[propName]},bubbles:!0,composed:!0}))}})}// execute an undo
},{key:"undo",value:function undo(){return this.undoStack.undo()}// execute a redo
},{key:"redo",value:function redo(){return this.undoStack.redo()}// return a list of the command stack
},{key:"commands",value:function commands(){return this.undoStack.commands}}]);return _class}(SuperClass))};_exports.UndoManagerBehaviors=UndoManagerBehaviors;var UndoManager=/*#__PURE__*/function(_UndoManagerBehaviors){babelHelpers.inherits(UndoManager,_UndoManagerBehaviors);function UndoManager(){babelHelpers.classCallCheck(this,UndoManager);return babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(UndoManager).apply(this,arguments))}babelHelpers.createClass(UndoManager,[{key:"render",/**
   * LitElement render
   */value:function render(){return(0,_litElement.html)(_templateObject_0861ca30812d11eb9c332bb120816628())}}],[{key:"tag",/**
   * Convention
   */get:function get(){return"undo-manager"}}]);return UndoManager}(UndoManagerBehaviors(_litElement.LitElement));_exports.UndoManager=UndoManager;customElements.define("undo-manager",UndoManager);/*
 * Fork of Undo.js - A undo/redo framework for JavaScript
 *
 * http://jzaefferer.github.com/undo
 *
 * Copyright (c) 2011 JÃ¶rn Zaefferer
 *
 * MIT licensed.
 */var Undo=/*#__PURE__*/function(){function Undo(){babelHelpers.classCallCheck(this,Undo);this.commands=[];this.undoStackPosition=-1;this.undoStackLimit=20}babelHelpers.createClass(Undo,[{key:"execute",value:function execute(command){// clear out the redo queue
this._clearRedo();// run the command (inner for inner)
command.execute();// if we're at our limit, start forgetting about past history but not all of it
if(this.undoStackLimit==this.commands.length){this.commands.splice(Math.round(this.commands.length/3),1)}else{// move the position forward
this.undoStackPosition++}// push the command into the stack
this.commands.push(command);this.changed()}},{key:"undo",value:function undo(){// sanity check
if(this.commands[this.undoStackPosition]){this.commands[this.undoStackPosition].undo();this.undoStackPosition--;this.changed()}}},{key:"canUndo",value:function canUndo(){return 0<=this.undoStackPosition}},{key:"redo",value:function redo(){if(this.commands[this.undoStackPosition+1]){this.undoStackPosition++;this.commands[this.undoStackPosition].redo();this.changed()}}},{key:"canRedo",value:function canRedo(){return this.undoStackPosition<this.commands.length-1}// remove right above where we are
},{key:"_clearRedo",value:function _clearRedo(){this.commands=this.commands.slice(0,this.undoStackPosition+1)}},{key:"changed",value:function changed(){// do nothing, override
}}]);return Undo}();/**
 * UndoManagerCommand, simple command scaffold to bridge undo.js with element
 */_exports.Undo=Undo;var UndoManagerCommand=/*#__PURE__*/function(){function UndoManagerCommand(el,oldValue,newValue){babelHelpers.classCallCheck(this,UndoManagerCommand);// refernece to us
this.el=el;this.oldValue=oldValue;this.newValue=newValue}// required for undo.js though we don't use
babelHelpers.createClass(UndoManagerCommand,[{key:"execute",value:function execute(){}// perform a "undo"
},{key:"undo",value:function undo(){this.el.undoStackIgnore=!0;// execute the change in value from what it was to what it is now
if(this.el.undoStack.commands&&this.el.undoStack.commands[this.el.undoStack.undoStackPosition-1]){this.el.innerHTML=this.el.undoStack.commands[this.el.undoStack.undoStackPosition-1].newValue}else if(this.el.undoStack.commands&&0===this.el.undoStack.undoStackPosition){this.el.innerHTML=this.el.undoStackInitialValue}else{this.el.innerHTML=this.oldValue}}// perform a "redo"
},{key:"redo",value:function redo(){this.el.undoStackIgnore=!0;this.el.innerHTML=this.newValue}}]);return UndoManagerCommand}();_exports.UndoManagerCommand=UndoManagerCommand});