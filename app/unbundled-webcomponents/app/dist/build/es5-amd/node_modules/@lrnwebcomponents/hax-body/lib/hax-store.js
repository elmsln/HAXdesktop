define(["exports","meta","require","../../../lit-element/lit-element.js","../../simple-popover/lib/simple-tour.js","../../utils/utils.js","../../../mobx/dist/mobx.esm.js","../../hax-body-behaviors/hax-body-behaviors.js"],function(_exports,meta,_require,_litElement,_simpleTour,_utils,_mobxEsm,_haxBodyBehaviors){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.HAXStore=_exports.HaxStore=void 0;meta=babelHelpers.interopRequireWildcard(meta);_require=babelHelpers.interopRequireWildcard(_require);function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable});keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var i=1,source;i<arguments.length;i++){source=null!=arguments[i]?arguments[i]:{};if(i%2){ownKeys(Object(source),!0).forEach(function(key){babelHelpers.defineProperty(target,key,source[key])})}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source))}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))})}}return target}function _templateObject_09f2ca70812d11eb9c332bb120816628(){var data=babelHelpers.taggedTemplateLiteral([" <slot></slot> "]);_templateObject_09f2ca70812d11eb9c332bb120816628=function _templateObject_09f2ca70812d11eb9c332bb120816628(){return data};return data}(0,_mobxEsm.configure)({enforceActions:!1,useProxies:"ifavailable"});// strict mode off
/**
 * @element hax-store
 */var HaxStore=/*#__PURE__*/function(_winEventsElement){babelHelpers.inherits(HaxStore,_winEventsElement);babelHelpers.createClass(HaxStore,[{key:"testHook",/**
   * test a hook's existance in a target
   */value:function testHook(el,op){return el&&"function"===typeof el.haxHooks&&el.haxHooks()[op]}/**
   * run a hook in a target if it exists
   */},{key:"runHook",value:function runHook(el,op){var data=2<arguments.length&&arguments[2]!==void 0?arguments[2]:[];if(this.testHook(el,op)){return el[el.haxHooks()[op]].apply(el,babelHelpers.toConsumableArray(data))}return!1}/**
   * Selection normalizer
   */},{key:"getSelection",value:function getSelection(){// try and obtain the selection from the nearest shadow
// which would give us the selection object when running native ShadowDOM
// with fallback support for the entire window which would imply Shady
if(this.activeHaxBody&&this.activeHaxBody.parentNode){// native API
if(this.activeHaxBody.parentNode.getSelection){return this.activeHaxBody.parentNode.getSelection()}// this could fail depending on polyfills and stuff
try{// ponyfill from google
if((0,_utils.getRange)(this.activeHaxBody.parentNode)){return(0,_utils.getRange)(this.activeHaxBody.parentNode)}}catch(e){}}// missed on both, hope the normal one will work
return window.getSelection()}/**
   * Get a normalized range based on current selection
   */},{key:"getRange",value:function getRange(){var sel=this.getSelection();if(sel.getRangeAt&&sel.rangeCount){return sel.getRangeAt(0)}else if(sel){return sel}else!1}/**
   * Try and guess the Gizmo based on what we were just handed
   */},{key:"guessGizmo",value:function guessGizmo(guess,values){var skipPropMatch=2<arguments.length&&arguments[2]!==void 0?arguments[2]:!1,preferExclusive=3<arguments.length&&arguments[3]!==void 0?arguments[3]:!1,matches=[];if(babelHelpers.typeof(guess)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// verify type
if(this.validGizmoTypes.includes(guess)){// now we can look through them
// look for a match
for(var gizmoposition in this.gizmoList){var gizmo=this.gizmoList[gizmoposition],props={},match=!1;// ensure this gizmo can handle things
if(gizmo&&gizmo.handles){for(var i=0;i<gizmo.handles.length;i++){// WHAT!??!?!?!?!
if(guess===gizmo.handles[i].type||"*"===guess&&!match){for(var property in gizmo.handles[i]){// ignore type.. but again.. WHAT?!?!?!
if("type"!==property){// check the values that came across to see if there's a match
// of any kind, we only need one but can then bind to multiple
if(babelHelpers.typeof(values[property])!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// but ensure there's either no meta data OR
// the meta data needs to NOT say anythinig about hiding
if("inline"===guess||!gizmo.meta||gizmo.meta&&!gizmo.meta.inlineOnly&&!gizmo.meta.hidden){match=!0;props[gizmo.handles[i][property]]=values[property]}}}}// omg... we just found a match on a property from who knows where!
if(match||skipPropMatch){if(preferExclusive&&gizmo.handles[i].type_exclusive){return[this.haxElementPrototype(gizmo,props,"")]}else{matches.push(this.haxElementPrototype(gizmo,props,""))}}}}}}}}return matches}/**
   * Simple workflow for logic from inserting based on
   * a series of criteria.
   */},{key:"insertLogicFromValues",value:function insertLogicFromValues(values,context){var failOnAnything=2<arguments.length&&arguments[2]!==void 0?arguments[2]:!1,type=this.guessGizmoType(values),typeName=type,preferExclusive=!0;if("*"==type){// allow for logic to bail completely if we are told to
if(failOnAnything){return!1}preferExclusive=!1;typeName="link"}var haxElements=this.guessGizmo(type,values,!1,preferExclusive);// see if we got anything
if(0<haxElements.length){if(1===haxElements.length){if(babelHelpers.typeof(haxElements[0].tag)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){context.dispatchEvent(new CustomEvent("hax-insert-content",{bubbles:!0,cancelable:!0,composed:!0,detail:haxElements[0]}))}}else{// hand off to hax-app-picker to deal with the rest of this
this.haxAppPicker.presentOptions(haxElements,type,"Pick how to present this "+typeName,"gizmo")}return!0}else{this.toast("Sorry, HAX doesn't know how to handle that type of link yet.");return!1}}/**
   * write to the store and communicate to all pieces
   */},{key:"write",value:function write(prop,value,obj){if(obj){obj.dispatchEvent(new CustomEvent("hax-store-write",{composed:!0,bubbles:!0,cancelable:!1,detail:{property:prop,value:value,owner:obj}}))}}/**
   * Convert a data mime type to gizmo type for rendering
   */},{key:"mimeTypeToGizmoType",value:function mimeTypeToGizmoType(mime){var parts=mime.split("/");switch(parts[0]){case"audio":return"audio";break;case"image":if("svg+xml"==parts[1]){return"svg"}return"image";break;case"video":return"video";break;case"text":if(["csv","html","markdown"].includes(parts[1])){return parts[1]}return"document";break;case"application":if("pdf"==parts[1]){return"pdf"}if(["zip","gzip","x-tar"].includes(parts[1])){return"archive"}return"document";break;}}/**
   * Guess the type of Gizmo when given some information about what we have.
   */},{key:"guessGizmoType",value:function guessGizmoType(guess){if(babelHelpers.typeof(guess.source)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){var source=guess.source.toLowerCase();if(-1!=source.indexOf(".mp3")||-1!=source.indexOf(".midi")||-1!=source.indexOf(".mid")){return"audio"}else if(-1!=source.indexOf(".png")||-1!=source.indexOf(".jpg")||-1!=source.indexOf(".jpeg")||-1!=source.indexOf(".gif")){return"image"}else if(-1!=source.indexOf(".pdf")){return"pdf"}else if(-1!=source.indexOf(".svg")){return"svg"}else if(-1!=source.indexOf(".csv")){return"csv"}else if(-1!=source.indexOf(".md")){return"markdown"}else if(-1!=source.indexOf(".html")||-1!=source.indexOf(".htm")){return"html"}else if(-1!=source.indexOf(".txt")||-1!=source.indexOf(".doc")||-1!=source.indexOf(".docx")||-1!=source.indexOf(".xls")||-1!=source.indexOf(".xlsx")||-1!=source.indexOf(".vtt")||-1!=source.indexOf(".ppt")){return"document"}else if(-1!=source.indexOf(".zip")||-1!=source.indexOf(".tar.gz")||-1!=source.indexOf(".tar")){return"archive"}// if it's external we can't assume what it actually is
else if("external"!=window.MediaBehaviors.Video.getVideoType(source)){return"video"}}// we don't know how to handle this so let's just
// try ANYTHING that matches
return"*"}/**
   * LitElement render
   */},{key:"render",value:function render(){return(0,_litElement.html)(_templateObject_09f2ca70812d11eb9c332bb120816628())}/**
   * convention
   */},{key:"toast",/**
   * Global toast bridge so we don't have to keep writing custom event
   */value:function toast(message){var duration=1<arguments.length&&arguments[1]!==void 0?arguments[1]:2e3,classStyle=2<arguments.length&&arguments[2]!==void 0?arguments[2]:"capsule",closeText=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null,eventCallback=4<arguments.length&&arguments[4]!==void 0?arguments[4]:null;// gets it all the way to the top immediately
window.dispatchEvent(new CustomEvent("simple-toast-show",{bubbles:!0,composed:!0,cancelable:!0,detail:{text:message,duration:duration,classStyle:classStyle,closeText:closeText,eventCallback:eventCallback}}))}/**
   * LitElement / popular convention
   */},{key:"_storageDataChanged",/**
   * Local storage data changed; callback to store this data in user storage
   */value:function _storageDataChanged(newValue){if(newValue&&this.ready&&this.__storageDataProcessed){if(window.localStorage.getItem("haxConfirm")){window.localStorage.setItem("haxUserData",JSON.stringify(newValue))}else if(window.sessionStorage.getItem("haxConfirm")){window.sessionStorage.setItem("haxUserData",JSON.stringify(newValue))}}}/**
   * If this is a text node or not so we know if the inline context
   * operations are valid.
   */},{key:"isTextElement",value:function isTextElement(node){var tag;// resolve HAXelements vs nodes
if(null!=node&&node.tagName){tag=node.tagName.toLowerCase()}else if(null!=node&&node.tag){tag=node.tag.toLowerCase()}if(tag&&this.validTagList.includes(tag)){if(["p","ol","ul","li","a","h1","h2","h3","h4","h5","h6","strike","u","b","sub","sup","span","i","bold","em","strong","blockquote","code","figure"].includes(tag)){return!0}}return!1}/**
   * test for being a valid grid plate, li is here because
   * nested lists make this really complicated
   */},{key:"isGridPlateElement",value:function isGridPlateElement(node){var tag;// resolve HAXelements vs nodes
if(node&&node.tagName){tag=node.tagName.toLowerCase()}else if(node&&node.tag){tag=node.tag.toLowerCase()}if(tag&&this.validGridTagList.includes(tag)){return!0}return!1}/**
   * Notice _appStore changed.
   */},{key:"_appStoreChanged",value:function _appStoreChanged(newValue,oldValue){// if we have an endpoint defined, pull it
if(newValue&&oldValue){// support having the request or remote loading
// depending on the integration type
if(newValue.url&&!newValue.apps&&this.shadowRoot){this.loadAppStoreFromRemote()}else{// directly injected json object into the DOM
this.__appStoreData=newValue}}}/**
   * Load and attach items from the app store.
   */},{key:"_loadAppStoreData",value:function _loadAppStoreData(appDataResponse){if(null!=appDataResponse){var items={};// autoload elements
if(babelHelpers.typeof(appDataResponse.autoloader)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// ensure the list is in the right order so we can async dynamic imports
// regardless of if its an array or object of values in the right format
// force this to be an object
appDataResponse.autoloader=Object.assign({},appDataResponse.autoloader);for(var i in appDataResponse.autoloader){var CEname=i,CEimport=appDataResponse.autoloader[i];// helps support array or object based app store spec
// array was originally in the standard so this lets us support both
if(!isNaN(CEname)){CEname=appDataResponse.autoloader[i];CEimport="@lrnwebcomponents/".concat(CEname,"/").concat(CEname,".js")}// force this into the valid tag list so early paints will
// correctly include the tag without filtering it out incorrectly
this.validTagList.push(CEname);items[CEname]=CEimport}}// load apps automatically
if(babelHelpers.typeof(appDataResponse.apps)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){for(var apps=appDataResponse.apps,i=0,app;i<apps.length;i++){app=document.createElement("hax-app");app.data=apps[i];this.appendChild(app)}}// load in stax dynamically
if(babelHelpers.typeof(appDataResponse.stax)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){for(var staxs=appDataResponse.stax,i=0,stax;i<staxs.length;i++){stax=document.createElement("hax-stax");stax.data=staxs[i];this.appendChild(stax)}}this.dispatchEvent(new CustomEvent("hax-store-app-store-loaded",{bubbles:!0,cancelable:!0,composed:!0,detail:!0}));// now process the dynamic imports
this._handleDynamicImports(items,this.haxAutoloader);this.__appStoreHasLoaded=!0}}// simple path from a url modifier
},{key:"pathFromUrl",value:function pathFromUrl(url){return url.substring(0,url.lastIndexOf("/")+1)}/**
   * Handle all the dynamic imports of things told to autoload
   * This ensures we get the definitions quickly as far as
   * what is a safe / valid tag above but then we import in a way
   * that allows us to correctly associate the hax schema to where
   * it came from.
   */},{key:"_handleDynamicImports",value:function(){var _handleDynamicImports2=babelHelpers.asyncToGenerator(/*#__PURE__*/regeneratorRuntime.mark(function _callee(items,haxAutoloader){var _this2=this,basePath,i;return regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:basePath=this.pathFromUrl(decodeURIComponent(meta.url));_context.t0=regeneratorRuntime.keys(items);case 2:if((_context.t1=_context.t0()).done){_context.next=12;break}i=_context.t1.value;if(!window.customElements.get(i)){_context.next=8;break}if(window.customElements.get(i).haxProperties){this.setHaxProperties(window.customElements.get(i).haxProperties,i)}else{// edge case of no definition
haxAutoloader.appendChild(document.createElement(i))}_context.next=10;break;case 8:_context.next=10;return new Promise(function(res,rej){return _require.default(["".concat(basePath,"../../../").concat(items[i])],res,rej)}).then(function(response){// see if it imported now
if(window.customElements.get(i)&&window.customElements.get(i).haxProperties){_this2.setHaxProperties(window.customElements.get(i).haxProperties,i)}else{// edge case of no definition
haxAutoloader.appendChild(document.createElement(i))}}).catch(function(error){/* Error handling */console.warn(error);// also try putting it in the autoloader and hope for the best
haxAutoloader.appendChild(document.createElement(i))});case 10:_context.next=2;break;case 12:case"end":return _context.stop();}}},_callee,this)}));function _handleDynamicImports(_x,_x2){return _handleDynamicImports2.apply(this,arguments)}return _handleDynamicImports}()},{key:"_editModeChanged",value:function _editModeChanged(newValue){if(this.__hal){if(newValue&&this.globalPreferences.haxVoiceCommands){this.__hal.auto=!0}else{this.__hal.auto=!1}}// trap for very slow loading environments that might miss on initial setup timing
if(newValue&&!this.__appStoreHasLoaded&&this.__appStoreData&&this.haxAutoloader){clearTimeout(this.__readyToProcessAppStoreData);this._loadAppStoreData(this.__appStoreData)}}},{key:"_globalPreferencesChanged",value:function _globalPreferencesChanged(newValue){var _this3=this;// regardless of what it is, reflect it globally but only after setup
if(this.__storageDataProcessed&&newValue&&babelHelpers.typeof(newValue.haxVoiceCommands)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&this.ready){var storageData=this.storageData;storageData.globalPreferences=newValue;this.storageData=storageData;this._storageDataChanged(this.storageData);// import voice command stuff in the background if used selects it
// this is experimental / aggressive import of tech so defer to
// if they activate it
if(newValue.haxVoiceCommands&&!this.__hal){// @todo only activate if the setting to use it is in place
new Promise(function(res,rej){return _require.default(["../../hal-9000/hal-9000.js"],res,rej)}).then(function(esModule){// initialize voice commands
_this3._initVoiceCommands();// inject tag into shadowRoot after we import the definition
_this3.__hal=document.createElement("hal-9000");_this3.__hal.respondsTo=_this3.voiceRespondsTo;_this3.__hal.debug=_this3.voiceDebug;_this3.__hal.auto=!0;_this3.shadowRoot.appendChild(_this3.__hal);// establish the initial commands, even if they were captured
// prior to usage since we held onto them in this variable
_this3.__hal.commands=_objectSpread({},_this3.voiceCommands)})}// only mess w/ hal if enabled
if(this.__hal){if(newValue.haxVoiceCommands&&this.editMode){this.__hal.auto=!0}else{this.__hal.auto=!1}}}}/**
   * A handful of context operations need to bubble up to the top
   * because we don't know where they originate from
   */},{key:"_haxContextOperation",value:function _haxContextOperation(e){var _this4=this,detail=e.detail;if(this.activeNode){var changed=!1;// support a simple insert event to bubble up or everything else
switch(detail.eventName){// directional / proportion operations
case"hax-align-left":this.activeNode.style.float=null;this.activeNode.style.margin=null;this.activeNode.style.display=null;changed=!0;break;case"hax-align-center":this.activeNode.style.float=null;this.activeNode.style.margin="0 auto";this.activeNode.style.display="block";changed=!0;break;case"hax-align-right":this.activeNode.style.float="right";this.activeNode.style.margin="0 auto";this.activeNode.style.display="block";changed=!0;break;case"hax-size-change":if(100==detail.value){this.activeNode.style.width=null}else{this.activeNode.style.width=detail.value+"%"}changed=!0;break;}if(changed){clearTimeout(this.__repositionMenu);this.__repositionMenu=setTimeout(function(){_this4.activeHaxBody.positionContextMenus()},0)}}}/**
   * This only send if they consented to storage of data locally
   */},{key:"_haxConsentTap",value:function _haxConsentTap(e){// store for future local storage usage
window.localStorage.setItem("haxConfirm",!0);// most likely nothing but set it anyway
window.localStorage.setItem("haxUserData",JSON.stringify(this.storageData))}},{key:"updated",value:function updated(changedProperties){var _this5=this;if(babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore.prototype),"updated",this)){babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore.prototype),"updated",this).call(this,changedProperties)}changedProperties.forEach(function(oldValue,propName){if("appStore"==propName&&_this5[propName]){_this5._appStoreChanged(_this5[propName],oldValue)}// composite obervation
if(["ready","__appStoreData","haxAutoloader"].includes(propName)&&_this5.ready&&_this5.__appStoreData&&_this5.haxAutoloader){clearTimeout(_this5.__readyToProcessAppStoreData);_this5.__readyToProcessAppStoreData=setTimeout(function(){_this5._loadAppStoreData(_this5.__appStoreData)},0)}if(["haxAutoloader","activeHaxBody","haxTray"].includes(propName)){// allow this to verify if everything is here or not
clearTimeout(_this5.__storeReady);_this5.__storeReady=setTimeout(function(){_this5._storePiecesAllHere(_this5.haxAutoloader,_this5.activeHaxBody,_this5.haxTray,_this5.haxExport)},0)}})}},{key:"_calculateActiveGizmo",value:function _calculateActiveGizmo(activeNode){if(null==activeNode||!activeNode.tagName){return null}for(var gizmoposition in this.gizmoList){var gizmo=this.gizmoList[gizmoposition];if(gizmo.tag===activeNode.tagName.toLowerCase()){return gizmo}}}/**
   * generate appstore query
   */},{key:"loadAppStoreFromRemote",value:function loadAppStoreFromRemote(){var _this6=this,searchParams=new URLSearchParams(this.appStore.params),url=this.appStore.url;if(searchParams){url+="?".concat(searchParams)}fetch(url,{method:this.method}).then(function(response){if(response.ok)return response.json()}).then(function(json){_this6.__appStoreData=json})}/**
   * ready life cycle
   */},{key:"firstUpdated",value:function firstUpdated(changedProperties){var _this7=this;if(babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore.prototype),"firstUpdated",this)){babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore.prototype),"firstUpdated",this).call(this,changedProperties)}// see if a global was used to prevent this check
// this is useful when in trusted environments where the statement
// has been consented to in the application this is utilized in
if(this.skipHAXConfirmation){window.sessionStorage.setItem("haxConfirm",!0);window.localStorage.setItem("haxConfirm",!0)}// check for local storage object
// if not, then store it in sessionStorage so that all our checks
// and balances are the same. This could allow for storing these
// settings on a server in theory
var haxConfirm=window.sessionStorage.getItem("haxConfirm")||window.localStorage.getItem("haxConfirm");if(!haxConfirm){// this way it isn't shown EVERY reload, but if they didn't confirm
// it will show up in the future
window.sessionStorage.setItem("haxConfirm",!0);var msg="\n    The HAX content editor keeps preferences in order to improve your experience.\n    This data is stored in your browser and is never sent anywhere.\n    Click to accept.\n    ";this.toast(msg,"-1","fit-bottom","I Accept","hax-consent-tap")}else{if(window.sessionStorage.getItem("haxConfirm")&&!window.localStorage.getItem("haxConfirm")){// verify there is something there
try{var globalData=window.sessionStorage.getItem("haxUserData")?JSON.parse(window.sessionStorage.getItem("haxUserData")):{};this.storageData=globalData;this._storageDataChanged(this.storageData)}catch(e){}}else{try{var _globalData=window.localStorage.getItem("haxUserData")?JSON.parse(window.localStorage.getItem("haxUserData")):{};this.storageData=_globalData;this._storageDataChanged(this.storageData)}catch(e){}}}// set this global flag so we know it's safe to start trusting data
// that is written to global preferences / storage bin
setTimeout(function(){_this7.__storageDataProcessed=!0;if(_this7.storageData.globalPreferences){_this7.write("globalPreferences",_this7.storageData.globalPreferences,_this7)}},0)}},{key:"_storePiecesAllHere",value:function _storePiecesAllHere(haxAutoloader,activeHaxBody,haxTray,haxExport){if(!this.ready&&activeHaxBody&&haxAutoloader&&haxTray&&haxExport){// send that hax store is ready to go so now we can setup the rest
this.dispatchEvent(new CustomEvent("hax-store-ready",{bubbles:!0,cancelable:!1,composed:!0,detail:!0}));// associate the export button in the tray to the dialog
HAXStore.haxExport.shadowRoot.querySelector("#dialog").associateEvents(haxTray.shadowRoot.querySelector("#exportbtn"));this.ready=!0;// register built in primitive definitions
this._buildPrimitiveDefinitions()}}/**
   * Build a list of common voice commands
   */},{key:"_initVoiceCommands",value:function _initVoiceCommands(){var _this8=this;this.__voiceInit=!0;this.voiceCommands["scroll up ".concat(this.voiceRespondsTo)]=function(){window.scrollBy({top:-(.5*window.innerHeight),left:0,behavior:"smooth"})};this.voiceCommands["scroll (down) ".concat(this.voiceRespondsTo)]=function(){window.scrollBy({top:.5*window.innerHeight,left:0,behavior:"smooth"})};this.voiceCommands["scroll to bottom ".concat(this.voiceRespondsTo)]=function(){window.scrollTo(0,document.body.scrollHeight)};this.voiceCommands["scroll to top ".concat(this.voiceRespondsTo)]=function(){window.scrollTo(0,0)};/**
     * Support for focusing active content and typing in it
     */this.voiceCommands["".concat(this.voiceRespondsTo," (show)(focus) active (element)(content)")]=function(){try{_this8._positionCursorInNode(_this8.activeNode)}catch(e){}};this.voiceCommands["".concat(this.voiceRespondsTo," (focus) previous (element)(content)")]=function(){if(_this8.activeNode.previousElementSibling){_this8.activeNode=_this8.activeNode.previousElementSibling;_this8.write("activeNode",_this8.activeNode,_this8);_this8._positionCursorInNode(_this8.activeNode)}else{_this8.speak("You are at the top of the document")}};this.voiceCommands["".concat(this.voiceRespondsTo," (focus) next (element)(content)")]=function(){if(_this8.activeNode.nextElementSibling){_this8.activeNode=_this8.activeNode.nextElementSibling;_this8.write("activeNode",_this8.activeNode,_this8);_this8._positionCursorInNode(_this8.activeNode)}else{_this8.speak("You are at the bottom of the document")}};this.voiceCommands["".concat(this.voiceRespondsTo," type *mycontent")]=function(e){if(_this8.isTextElement(_this8.activeNode)){try{var range=_this8._positionCursorInNode(_this8.activeNode),text=document.createTextNode(e);range.deleteContents();range.insertNode(text)}catch(e){_this8.speak("That didn't work");console.warn(e)}}else{_this8.speak("I'm sorry but I can only type in text areas. Try saying Insert Paragraph and try again.")}};// trolling
this.voiceCommands["hey ".concat(this.voiceRespondsTo)]=function(){_this8.speak("Yeah what do you want")};// trolling
this.voiceCommands["".concat(this.voiceRespondsTo," now your name is *splat")]=function(text){var past=_this8.voiceRespondsTo;_this8.speak("I used to be named ".concat(past," but you can call me ").concat(text," now."));_this8.voiceRespondsTo="(".concat(text,")");// @todo this needs to now update the previous commands somehow to match
// the new activation name
}}/**
   * Speak wrapper on hal to present as text too
   */},{key:"speak",value:function speak(text){if(this.__hal&&this.__hal.speak){this.__hal.speak(text)}// always show for accessibility
this.toast("".concat(this.voiceRespondsTo,": ").concat(text))}/**
   * allow uniform method of adding voice commands
   */},{key:"addVoiceCommand",value:function addVoiceCommand(command,context,callback){if(context){command=command.replace(":name:",this.voiceRespondsTo).toLowerCase();this.voiceCommands[command]=context[callback].bind(context);if(this.__voiceInit){this.__hal.commands=_objectSpread({},this.voiceCommands)}}}/**
   * event driven version
   */},{key:"_addVoiceCommand",value:function _addVoiceCommand(e){// without context it's almost worthless so try to fallback on where it came from
var target=e.detail.context;if(!target){target=e.target}this.addVoiceCommand(e.detail.command,target,e.detail.callback)}/**
   * Position cursor at the start of the position of the requested node
   */},{key:"_positionCursorInNode",value:function _positionCursorInNode(node){var position=1<arguments.length&&arguments[1]!==void 0?arguments[1]:0;this.activeHaxBody.positionContextMenus();var range=document.createRange(),sel=this.getSelection();range.setStart(node,position);range.collapse(!0);sel.removeAllRanges();sel.addRange(range);return range}/**
   * Before the browser closes / changes paths, ask if they are sure they want to leave
   */},{key:"_onBeforeUnload",value:function _onBeforeUnload(e){// ensure we don't leave DURING edit mode
if(!this.skipExitTrap&&this.editMode){return"Are you sure you want to leave? Your work will not be saved!"}}/**
   * detect base64 object
   */},{key:"isBase64",value:function isBase64(str){try{return btoa(atob(str))==str}catch(err){return!1}}},{key:"retrieveImageFromClipboardAsBlob",value:function retrieveImageFromClipboardAsBlob(pasteEvent,callback){if(!1==pasteEvent.clipboardData){if("function"==typeof callback){return callback(void 0)}}var items=pasteEvent.clipboardData.items;if(items==void 0){if("function"==typeof callback){return callback(void 0)}}for(var i=0;i<items.length;i++){// Skip content if not image
if(-1==items[i].type.indexOf("image"))continue;// Retrieve image on clipboard as blob
var blob=items[i].getAsFile();if("function"==typeof callback){return callback(blob)}}}/**
   * Intercept paste event and clean it up before inserting the contents
   */},{key:"_onPaste",value:function _onPaste(e){var _this9=this;if(this.editMode&&"HAX-TRAY"!==document.activeElement.tagName&&"BODY"!==document.activeElement.tagName&&"SIMPLE-MODAL"!==document.activeElement.tagName){// only perform this on a text element that is active
// otherwise inject a P so we can paste into it
if(this.isTextElement(this.activeNode)){}else{this.activeNode=this.activeHaxBody.haxInsert("p","",{})}var pasteContent="",originalContent="";// intercept paste event
if(e.clipboardData||e.originalEvent.clipboardData){pasteContent=(e.originalEvent||e).clipboardData.getData("text/html");// if it is purely plain text it could fail to come across as HTML and be empty
if(""==pasteContent){pasteContent=(e.originalEvent||e).clipboardData.getData("text")}}else if(window.clipboardData){pasteContent=window.clipboardData.getData("Text")}originalContent=pasteContent;// look for base64 like copy and paste of an image from clipboard
if(this.isBase64(originalContent)){// stop normal paste
e.preventDefault();e.stopPropagation();e.stopImmediatePropagation();return this.retrieveImageFromClipboardAsBlob(e,function(imageBlob){// If there's an image, display it in the canvas
if(imageBlob){// Crossbrowser support for URL
var URLObj=window.URL||window.webkitURL,img=document.createElement("img");// turn blob into a url to visualize locally, this is just temporary
img.src=URLObj.createObjectURL(imageBlob);_this9.activeNode.parentNode.insertBefore(img,_this9.activeNode.nextElementSibling);for(var i in e.clipboardData.items){// generate a file name if one doesn't exist
if(!e.clipboardData.items[i].name&&e.clipboardData.items[i].type){e.clipboardData.items[i].name="image-"+Math.floor(Date.now()/1e3)+e.clipboardData.items[i].type.replace("image/",".")}}// cannot believe this actually works
e.dataTransfer=e.clipboardData;// refernece of what to replace; this way while uploading, we still see
// what we pasted and it's in place. It'll gracefully switch over to the
// real file reference once it finishes uploading
e.placeHolderElement=img;// fire this specialized event up so things like HAX can intercept
_this9.dispatchEvent(new CustomEvent("place-holder-file-drop",{bubbles:!0,cancelable:!0,composed:!0,detail:e}));return img}return!1})}// we have a "file" paste
else if(0<e.clipboardData.files.length){// stop normal paste
e.preventDefault();e.stopPropagation();e.stopImmediatePropagation();// generate a place holder p tag to replace on upload
var p=this.activeHaxBody.haxInsert("p","",{});// cannot believe this actually works
e.dataTransfer=e.clipboardData;for(var i in e.clipboardData.files){// generate a file name if one doesn't exist
if(!e.clipboardData.files[i].name&&e.clipboardData.files[i].type){e.clipboardData.files[i].name="image-"+Math.floor(Date.now()/1e3)+e.clipboardData.files[i].type.replace("image/",".")}}// refernece of what to replace; this way while uploading, we still see
// what we pasted and it's in place. It'll gracefully switch over to the
// real file reference once it finishes uploading
e.placeHolderElement=p;// fire this specialized event up so things like HAX can intercept
this.dispatchEvent(new CustomEvent("place-holder-file-drop",{bubbles:!0,cancelable:!0,composed:!0,detail:e}))}// detect word garbage
var inlinePaste=!1,newContent="";// the string to import as sanitized by hax
// clear empty span tags that can pop up
pasteContent=pasteContent.replace(/<span>\s*?<\/span>/g," ");// clean up div tags that can come in from contenteditable pastes
// p tags make more sense in the content area
pasteContent=pasteContent.replace(/<div/g,"<p");pasteContent=pasteContent.replace(/<\/div>/g,"</p>");// NOW we can safely handle paste from word cases
pasteContent=(0,_utils.stripMSWord)(pasteContent);// edges that some things preserve empty white space needlessly
var haxElements=this.htmlToHaxElements(pasteContent);// if interpretation as HTML fails then let's ignore this whole thing
// as we allow normal contenteditable to handle the paste
// we only worry about HTML structures
if(0===haxElements.length&&(0,_utils.validURL)(pasteContent)){// ONLY use this logic if we're on an empty container
if(""!=this.activeNode.innerText.trim()){return!1}// test for a URL since we didn't have HTML / elements of some kind
// if it's a URL we might be able to automatically convert it into it's own element
var values={source:pasteContent,title:pasteContent};// if we DID get a match, block default values
if(!this.insertLogicFromValues(values,this)){// prevents the text being inserted previously so that the insertLogic does it
// for us. false only is returned if we didn't do anthing in this function
return!1}}else if(0===haxElements.length){inlinePaste=!0;// wrap in a paragraph tag if there is any this ensures it correctly imports
// as it might not have evaluated above as having elements bc of the scrubber
if(originalContent!=pasteContent){newContent=pasteContent}else{return!1}}// account for incredibly basic pastes of single groups of characters
else if(1===haxElements.length&&"p"===haxElements[0].tag){newContent=pasteContent;inlinePaste=!0}// account for incredibly basic pastes of single groups of characters
else if(1===haxElements.length&&"a"===haxElements[0].tag&&haxElements[0].properties.href){// ONLY use this logic if we're on an empty container
if(""!=this.activeNode.innerText.trim()){newContent=haxElements[0].properties.href;inlinePaste=!0}else{// test for a URL since we didn't have HTML / elements of some kind
// if it's a URL we might be able to automatically convert it into it's own element
var _values={source:haxElements[0].properties.href,title:haxElements[0].content};// if we DID get a match, block default values
if(!this.insertLogicFromValues(_values,this)){return!1}}}// account for broken pastes in resolution, just let browser handle it
else if(!this.isGridPlateElement(haxElements[0])){return!1}else{for(var i in haxElements){// special support for pasting into a list of items
if("p"==haxElements[i].tag&&["li","ol","ul"].includes(this.activeNode.tagName.toLowerCase())){haxElements[i].tag="li"}// special traps for word / other styles bleeding through
delete haxElements[i].properties.style;delete haxElements[i].properties.start;delete haxElements[i].properties.align;// this is not the right function.
var node=(0,_utils.haxElementToNode)({tag:haxElements[i].tag,content:haxElements[i].content.replace(/<span>&nbsp;<\/span>/g," ").trim(),properties:haxElements[i].properties});newContent+=this.nodeToContent(node)}}// if we got here then we have HTML structures to pull together
// this ensures that the below works out
e.preventDefault();e.stopPropagation();e.stopImmediatePropagation();try{// get the range that's active and selection
var range=this.getRange(),sel=this.getSelection(),newNodes=document.createElement("div");// defined so that we can
newNodes.innerHTML=newContent;if(range&&sel){for(var i in newNodes.children){// delete nodes that are empty text elements
if(newNodes.children[i].tagName&&this.isTextElement(newNodes.children[i])&&""===newNodes.children[i].innerHTML){newNodes.children[i].remove()}}if(inlinePaste){var txt=document.createTextNode(newNodes.innerHTML);range.insertNode(txt);setTimeout(function(){_this9._positionCursorInNode(txt,txt.length)},0)}else{var _enterSplit,activeEl,siblingEl;// only insert a P if we are splitting something
if(""!=this.activeNode.innerText.trim()&&range.endOffset!=this.activeNode.innerText.length){_enterSplit=!0;document.execCommand("insertParagraph")}// sanity check and then insert our new paste node right AFTER the thing we are pasting in the middle of
// this hopefully captures complex HTML pastes and inserts them in a logical way
if(range.commonAncestorContainer&&range.commonAncestorContainer.parentNode){if(!siblingEl&&this.activeNode!=range.commonAncestorContainer){siblingEl=range.commonAncestorContainer.parentNode;if(!siblingEl){siblingEl=range.commonAncestorContainer}}}while(newNodes.firstElementChild){activeEl=newNodes.firstElementChild;// should always be there but just in case there was no range
// so we avoid an infinite loop
if(siblingEl){// account for a potential textnode
if(siblingEl.getAttribute&&siblingEl.getAttribute("slot")){activeEl.setAttribute("slot",siblingEl.getAttribute("slot"))}// if we split an item at the very front with the enter key
// and we are pasting in complex content then we need to
// make sure that we move things AHEAD of what will be moved down
if(_enterSplit){this.activeHaxBody.haxReplaceNode(siblingEl.previousElementSibling,activeEl);_enterSplit=!1}else{siblingEl.parentNode.insertBefore(activeEl,siblingEl.nextElementSibling)}}// attempt insert after active
else if(this.activeNode){if(this.activeNode.getAttribute("slot")){activeEl.setAttribute("slot",this.activeNode.getAttribute("slot"))}// if we have an empty element we are hitting paste on
// then leverage it for the 1st item as opposed to making a new line
if(""==this.activeNode.innerText.trim()){this.activeHaxBody.haxReplaceNode(this.activeNode,activeEl)}else{this.activeNode.parentNode.insertBefore(activeEl,this.activeNode.nextElementSibling)}}// shouldn't be possible but just to be safe
else{this.activeHaxBody.appendChild(activeEl)}siblingEl=activeEl}setTimeout(function(){if(activeEl&&activeEl.childNodes&&activeEl.childNodes[0]){_this9._positionCursorInNode(activeEl.childNodes[0],activeEl.childNodes[0].length);activeEl=null;siblingEl=null}},0)}}}catch(e){console.warn(e)}}}// HTML primatives which are valid grid plate elements
},{key:"__validGridTags",value:function __validGridTags(){return["p","ol","ul","li","div","h1","h2","h3","h4","h5","h6","blockquote","code","figure"]}// internal list of HTML primatives which are valid
},{key:"__validTags",value:function __validTags(){return["p","div","span","table","caption","sup","sub","u","strike","tr","th","td","ol","ul","li","a","strong","kbd","tt","em","i","b","hr","h1","h2","h3","h4","h5","h6","blockquote","code","figure","img","iframe","video","audio","section","grid-plate","template","webview"]}/**
   * Types that we deem as valid
   */},{key:"__validGizmoTypes",value:function __validGizmoTypes(){return["data","video","audio","text","link","file","pdf","image","csv","doc","archive","markdown","html","wikipedia","content","text","inline","*"]}/**
   * Created life-cycle to ensure a single global store.
   */}],[{key:"tag",get:function get(){return"hax-store"}},{key:"properties",get:function get(){return _objectSpread({},babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore),"properties",this),{voiceDebug:{type:Boolean,attribute:"voice-debug"},voiceRespondsTo:{type:String,attribute:"voice-responses-to"},/**
       * skipHAXConfirmation
       */skipHAXConfirmation:{type:Boolean,reflect:!0,attribute:"skip-hax-confirmation"},/**
       * Local storage bridge
       */storageData:{type:Object},/**
       * Hax tray
       */haxTray:{type:Object},/**
       * Hax autoloader element.
       */haxAutoloader:{type:Object},/**
       * A list of all haxBodies that exist
       */haxBodies:{type:Array},/**
       * An active place holder item reference. This is used
       * for inline drag and drop event detection so that we
       * know what element replace in context.
       */activePlaceHolder:{type:Object},/**
       * Possible appStore endpoint for loading in things dynamically.
       */appStore:{type:Object},/**
       * Session object bridged in from a session method of some kind
       */sessionObject:{type:Object},/**
       * skip the exit trap to prevent losing data
       */skipExitTrap:{type:Boolean},/**
       * Available elements keyed by tagName and with
       * their haxProperties centrally registered.
       */elementList:{type:Object},/**
       * Available hax stax which are just re-usable templates
       */staxList:{type:Array},/**
       * Valid tag list, tag only and including primatives for a baseline.
       */validTagList:{type:Array},/**
       * Valid tag list, tag only and including primatives for a baseline.
       */validGridTagList:{type:Array},/**
       * Gizmo types which can be used to bridge apps to gizmos.
       */validGizmoTypes:{type:Array},/**
       * Sandboxed environment test
       */_isSandboxed:{type:Boolean},/**
       * Internal app store data property after request
       */__appStoreData:{type:Object},ready:{type:Boolean},/**
       * Support for deploy specific rewriting for things like JWTs
       */connectionRewrites:{type:Object}})}}]);function HaxStore(){var _this;babelHelpers.classCallCheck(this,HaxStore);_this=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(HaxStore).call(this));_this.method="GET";_this.haxSelectedText="";_this.__winEvents={"hax-register-properties":"_haxStoreRegisterProperties","hax-consent-tap":"_haxConsentTap","hax-context-item-selected":"_haxContextOperation",onbeforeunload:"_onBeforeUnload",paste:"_onPaste","hax-register-app":"_haxStoreRegisterApp","hax-register-stax":"_haxStoreRegisterStax","hax-store-write":"_writeHaxStore","hax-register-core-piece":"_haxStorePieceRegistrationManager","hax-register-body":"_haxStoreRegisterBody","hax-insert-content":"_haxStoreInsertContent","hax-insert-content-array":"_haxStoreInsertMultiple","hax-add-voice-command":"_addVoiceCommand"};// prevent leaving if we are in editMode
window.onbeforeunload=function(e){if(!_this.skipExitTrap&&_this.editMode){var saving="Are you sure you want to leave? Your work will not be saved!";e.returnValue=saving;return saving}};// establish the tour
_simpleTour.SimpleTourManager.registerNewTour({key:"hax",name:"Let's learn HAX",style:"\n      simple-popover-manager::part(simple-popover) {\n        max-width: 250px;\n      }\n      simple-popover-manager button {\n        font-size: 12px;\n        margin: 0px 2px;\n      }\n      simple-popover-manager p {\n        --hax-base-styles-p-font-size: 14px;\n        padding: 0;\n        margin: 0;\n        font-size: 14px;\n        line-height: 20px;\n      }\n      simple-popover-manager h3 {\n        --hax-base-styles-h3-font-size: 18px;\n        margin: 8px 2px;\n      }"});_this.voiceRespondsTo="(worker)";_this.voiceCommands={};_this.skipHAXConfirmation=!1;_this.storageData={};_this.appStore={url:"",params:{}};_this.activeNode=null;_this.activeEditingElement=null;_this.haxBodies=[];_this.activePlaceHolder=null;_this.sessionObject={};_this.editMode=!1;_this.skipExitTrap=!1;_this.elementList={};_this.appList=[];_this.gizmoList=[];_this.activeHaxBody=null;_this.staxList=[];_this.globalPreferences={};_this.activeApp={};_this.connectionRewrites={};// change this in order to debug voice commands
_this.voiceDebug=!1;// keyboard shortcuts, implementing haxHook: gizmoRegistration can ovewrite these as needed
_this.keyboardShortcuts={"#":{tag:"h2",content:""},"##":{tag:"h3",content:""},"###":{tag:"h4",content:""},"####":{tag:"h5",content:""},"#####":{tag:"h6",content:""},"-":{tag:"ul",content:"<li></li>"},"1.":{tag:"ol",content:"<li></li>"},"---":{tag:"hr"},"```":{tag:"code",content:""},">":{tag:"blockquote",content:""}};_this.validTagList=_this.__validTags();_this.validGridTagList=_this.__validGridTags();_this.validGizmoTypes=_this.__validGizmoTypes();// test for sandboxed env
var test=document.createElement("webview");_this._isSandboxed="function"===typeof test.reload;// imports app, stax definitions
new Promise(function(res,rej){return _require.default(["./hax-app.js"],res,rej)});new Promise(function(res,rej){return _require.default(["../../simple-toast/simple-toast.js"],res,rej)}).then(function(){window.SimpleToast.requestAvailability()});new Promise(function(res,rej){return _require.default(["../../media-behaviors/media-behaviors.js"],res,rej)});document.body.style.setProperty("--hax-ui-headings","#d4ff77");// mobx
(0,_mobxEsm.makeObservable)(babelHelpers.assertThisInitialized(_this),{gizmoList:_mobxEsm.observable,activeNode:_mobxEsm.observable,globalPreferences:_mobxEsm.observable,activeGizmo:_mobxEsm.computed,editMode:_mobxEsm.observable,appList:_mobxEsm.observable,activeApp:_mobxEsm.observable,haxSelectedText:_mobxEsm.observable,activeEditingElement:_mobxEsm.observable,activeHaxBody:_mobxEsm.observable});(0,_mobxEsm.autorun)(function(){_this._globalPreferencesChanged((0,_mobxEsm.toJS)(_this.globalPreferences))});(0,_mobxEsm.autorun)(function(){_this._editModeChanged((0,_mobxEsm.toJS)(_this.editMode))});return _this}/**
   * Build HAX property definitions for primitives that we support.
   */babelHelpers.createClass(HaxStore,[{key:"_buildPrimitiveDefinitions",value:function _buildPrimitiveDefinitions(){// sandboxes need a webview definition
// we don't want people making them but we need to
// know how to edit them if asked
if(this._isSandboxed){var webview={type:"element",editingElement:"core",canScale:!0,canPosition:!0,canEditSource:!0,settings:{configure:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"textfield",icon:"link",required:!0,validationType:"url"}],advanced:[]}};this.setHaxProperties(webview,"webview")}var iframe={type:"element",editingElement:"core",canScale:!0,canPosition:!0,canEditSource:!0,gizmo:{title:"Basic iframe",description:"A basic iframe",icon:"icons:fullscreen",color:"blue-grey",groups:["Content"],handles:[{type:"link",source:"src",height:"height",width:"width"},{type:"pdf",source:"src",height:"height",width:"width"},{type:"document",source:"src",height:"height",width:"width"},{type:"html",source:"src",height:"height",width:"width"}],meta:{author:"W3C"}},settings:{configure:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"textfield",icon:"link",required:!0,validationType:"url"}],advanced:[{attribute:"loading",title:"Loading method",description:"Whether or not to lazy load this",inputMethod:"select",options:{lazy:"Load when visible",auto:"Automatic"}}]}};this.setHaxProperties(iframe,"iframe");var img={canScale:{min:10,step:5},type:"element",editingElement:"core",canPosition:!0,canEditSource:!0,gizmo:{title:"Image",description:"A basic img tag",icon:"image:image",color:"blue-grey",groups:["Image","Media"],handles:[{type:"link",source:"src"},{type:"image",type_exclusive:!0,source:"src",height:"height",width:"width"}],meta:{author:"W3C"}},settings:{configure:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"haxupload",icon:"link",required:!0,validationType:"url"},{attribute:"alt",title:"Alt text",description:"Useful for screen readers and improved SEO.",inputMethod:"alt",icon:"accessibility"},{attribute:"height",title:"Height",description:"height in pixels of the item. Leave blank to respond to the natural resolution",inputMethod:"textfield",icon:"icons:swap-vert"}],advanced:[{attribute:"aria-describedby",title:"Aria-describedby",description:"Space-separated list of IDs for elements that describe the image.",inputMethod:"textfield",icon:"accessibility"},{attribute:"loading",title:"Loading method",description:"Whether or not to lazy load this",inputMethod:"select",options:{lazy:"Load when visible",auto:"Automatic"}}]}};this.setHaxProperties(img,"img");var ahref={type:"element",editingElement:"core",canScale:!1,canPosition:!1,canEditSource:!0,contentEditable:!0,gizmo:{title:"Basic link",description:"A basic a tag",icon:"icons:link",color:"blue-grey",groups:["Link"],handles:[],meta:{author:"W3C"}},settings:{configure:[{attribute:"innerText",title:"Text",description:"Text of the link",inputMethod:"textfield",required:!0},{attribute:"href",title:"Link",description:"The URL for this video.",inputMethod:"haxupload",icon:"icons:link",required:!0,validationType:"url"},{attribute:"title",title:"Title text",description:"Useful for screen readers and improved SEO.",inputMethod:"textfield",icon:"icons:accessibility"},{attribute:"target",title:"Target",description:"Where to place the link.",inputMethod:"select",icon:"icons:launch",options:{"":"Same window",_blank:"New window",_top:"Top window",_parent:"Parent window"}}],advanced:[]}};// anything can be presented as a link
this.validGizmoTypes.forEach(function(val){ahref.gizmo.handles.push({type:val,source:"href",title:"innerText",alt:"title"})});this.setHaxProperties(ahref,"a");var p={type:"element",editingElement:"core",// comment back in when ready to keep cleaning up shadowRoot resolution of focus
/*editingElement: {
        tag: "simple-autocomplete-text-trigger",
        import:
          "@lrnwebcomponents/simple-autocomplete/lib/simple-autocomplete-text-trigger.js",
        callback: this.setupAutocomplete.bind(this),
      },*/canScale:!1,canPosition:!1,canEditSource:!0,contentEditable:!0,gizmo:{title:"Paragraph",description:"A basic text area",icon:"hax:paragraph",color:"blue-grey",groups:["Content"],handles:[{type:"content",content:""}],meta:{author:"W3C"}},settings:{configure:[],advanced:[]},demoSchema:[{tag:"p",content:"Text",properties:{}}]};this.setHaxProperties(p,"p");// table tag which has a custom editing interface
var table={type:"element",editingElement:{tag:"editable-table",import:"@lrnwebcomponents/editable-table/editable-table.js"},canScale:!0,canPosition:!0,canEditSource:!0,gizmo:{title:"Table",description:"A table for displaying data",icon:"image:grid-on",color:"blue-grey",groups:["Content","Table","Data"],meta:{author:"W3C"}},settings:{configure:[],advanced:[]},demoSchema:[{tag:"table",content:"<tr><td>-</td><td>-</td><td>-</td></tr><tr><td>-</td><td>-</td><td>-</td></tr><tr><td>-</td><td>-</td><td>-</td></tr>",properties:{}}]};this.setHaxProperties(table,"table");var prims={caption:{title:"Caption",icon:"av:call-to-action"},video:{title:"Video",icon:"av:play-circle-filled"},audio:{title:"Audio",icon:"image:music-note"},section:{title:"Section",icon:"image:crop-landscape"},ol:{title:"Numbered list",icon:"editor:format-list-numbered"},ul:{title:"Bulleted list",icon:"editor:format-list-bulleted"},li:{title:"List item",icon:"editor:format-list-bulleted"},h1:{title:"Heading",icon:"hax:h1"},h2:{title:"Heading",icon:"hax:h2"},h3:{title:"Heading",icon:"hax:h3"},h4:{title:"Heading",icon:"hax:h4"},h5:{title:"Heading",icon:"hax:h5"},h6:{title:"Heading",icon:"hax:h6"},strike:{title:"Cross out",icon:"editor:format-strikethrough"},u:{title:"Underline",icon:"editor:format-underlined"},sub:{title:"Subscript",icon:"mdextra:subscript"},sup:{title:"Superscript",icon:"mdextra:superscript"},div:{title:"DIV",icon:"image:crop-landscape"},span:{title:"SPAN",icon:"editor:short-text"},i:{title:"Italic",icon:"editor:format-italic"},em:{title:"Emphasis",icon:"editor:format-italic"},strong:{title:"Bold",icon:"editor:format-bold"},b:{title:"Bold",icon:"editor:format-bold"},blockquote:{title:"Block quote",icon:"editor:format-quote"},code:{title:"Code",icon:"icons:code"},figure:{title:"Figure",icon:"icons:label-outline"},embed:{title:"Embedded object",icon:"icons:fullscreen"}};for(var tag in prims){this.setHaxProperties({type:"element",editingElement:"core",canScale:!1,canPosition:!1,canEditSource:!0,contentEditable:!0,gizmo:{title:prims[tag].title,icon:prims[tag].icon,meta:{hidden:"h2"==tag?!1:!0}},settings:{configure:[],advanced:[]},demoSchema:[{tag:tag,content:"h2"==tag?"Heading":"",properties:{}}]},tag)}var hr={canScale:{min:25,step:25},type:"element",editingElement:"core",canPosition:!1,canEditSource:!1,contentEditable:!0,gizmo:{title:"Horizontal line",icon:"hax:hr",meta:{author:"W3C"}},settings:{configure:[],advanced:[]},demoSchema:[{tag:"hr",content:"",properties:{style:"width:50%;"}}]};this.setHaxProperties(hr,"hr")}/**
   * A standard event for registering the different pieces of HAX that check in
   * at run time. This allows for additional flexibility down the road as well as
   * registering pieces we never thought of for custom environments.
   * This also ensures that there are object references in the central store
   * but that load at an unknown time during spin up.
   *
   * @param {CustomEvent} e an event that has the piece to register and the object
   */},{key:"_haxStorePieceRegistrationManager",value:function _haxStorePieceRegistrationManager(e){if(e.detail&&e.detail.piece&&e.detail.object){this[e.detail.piece]=e.detail.object}}/**
   * set up the autocomplete contextual settings
   */},{key:"setupAutocomplete",value:function setupAutocomplete(editor){var _this10=this;editor.triggers={"!":function _(el){var triggers=[];_this10.gizmoList.forEach(function(item){triggers.push({groups:item.groups&&item.groups.length?item.groups.join(" "):"",icon:item.icon,label:item.title,value:item.tag})});return triggers}}}/**
   * Insert content in the body.
   */},{key:"_haxStoreInsertContent",value:function _haxStoreInsertContent(e){if(e.detail){var details=e.detail;if(window.customElements.get(details.tag)){var prototypeNode=document.createElement(details.tag);// @see haxHooks: preProcessInsertContent
if(this.testHook(prototypeNode,"preProcessInsertContent")){details=this.runHook(prototypeNode,"preProcessInsertContent",[details])}}var properties={};// support for properties to be set automatically optionally
if(babelHelpers.typeof(details.properties)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){properties=details.properties}// support / clean up properties / attributes that have innerHTML / innerText
// these are reserved words but required for certain bindings
if(properties.innerHTML){if(""==details.content){details.content=properties.innerHTML}delete properties.innerHTML}if(properties.innerText){if(""==details.content){details.content=properties.innerText}delete properties.innerText}// invoke insert or replacement on body, same function so it's easier to trace
if(babelHelpers.typeof(details.__type)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"inline"===details.__type){var node=(0,_utils.haxElementToNode)({tag:details.tag,content:details.content,properties:properties});// replace what WAS the active selection w/ this new node
if(null!==this.activePlaceHolder){this.activePlaceHolder.deleteContents();this.activePlaceHolder.insertNode(node)}// set it to nothing
this.activePlaceHolder=null}else if(details.replace||details.replacement||details.nextToActive){var _node=(0,_utils.haxElementToNode)({tag:details.tag,content:details.content,properties:properties});if(this.activePlaceHolder){this.activeHaxBody.haxReplaceNode(this.activePlaceHolder,_node);this.activePlaceHolder=null}else if(details.nextToActive&&this.activeNode){// special support for an active slot
if(this.activeHaxBody.__slot&&"GRID-PLATE"===this.activeNode.tagName){this.activeNode.appendChild(_node)}else{this.activeNode.parentNode.insertBefore(_node,this.activeNode)}}else{this.activeHaxBody.haxReplaceNode(this.activeNode,_node)}}else if(this.activeNode.parentNode&&"HAX-BODY"!=this.activeNode.parentNode.tagName){var _node2=(0,_utils.haxElementToNode)({tag:details.tag,content:details.content,properties:properties});// allow for inserting things into things but not grid plate
if("GRID-PLATE"===this.activeNode.parentNode.tagName){// support slot if we have one on the activeNode (most likely)
if(null!=this.activeNode.getAttribute("slot")){_node2.setAttribute("slot",this.activeNode.getAttribute("slot"))}this.activeHaxBody.haxInsert(details.tag,details.content,properties)}else{this.activeHaxBody.haxInsert(details.tag,details.content,properties)}}else{this.activeHaxBody.haxInsert(details.tag,details.content,properties)}}}/**
   * get the schema from a tag
   */},{key:"haxSchemaFromTag",value:function haxSchemaFromTag(tag){tag=tag.toLowerCase();if(this.elementList&&this.elementList[tag]){return this.elementList[tag]}return{}}/**
   * Optional send array, to improve performance and event bubbling better
   */},{key:"_haxStoreInsertMultiple",value:function _haxStoreInsertMultiple(e){if(e.detail){var properties;for(var i in e.detail){properties={};// support for properties to be set automatically optionally
if(babelHelpers.typeof(e.detail[i].properties)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){properties=e.detail[i].properties}this.activeHaxBody.haxInsert(e.detail[i].tag,e.detail[i].content,properties)}}}/**
   * Set the activeHaxBody and add to the list so we know what to insert into.
   */},{key:"_haxStoreRegisterBody",value:function _haxStoreRegisterBody(e){if(e.detail){this.haxBodies.push(e.detail);// default active the whatever is last here
this.activeHaxBody=e.detail;// needed so that higher order things can respond to us having a body
this.write("activeHaxBody",this.activeHaxBody,this);this.write("editMode",this.editMode,this)}}/**
   * Feature detect on the bar.
   */},{key:"computePolyfillSafe",value:function computePolyfillSafe(){/**
     * These are our bad actors in polyfill'ed browsers.
     * This means that https://github.com/webcomponents/webcomponentsjs/commit/ce464bb533bf39b544c312906499a6044ee0d30d
     * explains things but basically if shadow-dom is polyfilled
     * then we can't safely execute a DOM manipulating execCommand.
     * This
     */if(document.head.createShadowRoot||document.head.attachShadow){return!0}else{console.warn("Shadow DOM missing, certain operations hidden");return!1}}/**
   * Write store event callback.
   */},{key:"_writeHaxStore",value:function _writeHaxStore(e){// ensure we have a valid store write
if(e.detail&&babelHelpers.typeof(e.detail.value)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&e.detail.property&&e.detail.owner){// only update US if we didn't originate this message
if(e.detail.owner!==this){if(null==e.detail.value){this[e.detail.property]=null}else if("object"===babelHelpers.typeof(e.detail.value)){this[e.detail.property]={}}this[e.detail.property]=e.detail.value}// tell everyone regardless
this.dispatchEvent(new CustomEvent("hax-store-property-updated",{bubbles:!0,composed:!0,cancelable:!1,detail:{property:e.detail.property,value:e.detail.value,owner:e.detail.owner}}))}}/**
   * Notice that an app was set in HAX; register it
   */},{key:"_haxStoreRegisterApp",value:function _haxStoreRegisterApp(e){if(e.detail){e.detail.index=this.appList.length;this.appList=[].concat(babelHelpers.toConsumableArray(this.appList),[e.detail]);this.write("appList",this.appList,this);// preconnect apps at registration time
if(e.detail.connection&&e.detail.connection.protocol&&e.detail.connection.url){var preconnectlink=document.createElement("link");preconnectlink.rel="preconnect";preconnectlink.href=e.detail.connection.protocol+"://"+e.detail.connection.url;document.head.appendChild(preconnectlink)}// we don't care about this after it's launched
if(babelHelpers.typeof(e.target.parentElement)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"HAX-STORE"===e.target.parentElement.tagName){e.target.parentElement.removeChild(e.target)}}}/**
   * Notice that a stax was set in HAX; register it
   */},{key:"_haxStoreRegisterStax",value:function _haxStoreRegisterStax(e){if(e.detail){e.detail.index=this.staxList.length;this.staxList=[].concat(babelHelpers.toConsumableArray(this.staxList),[e.detail]);this.write("staxList",this.staxList,this);// we don't care about this after it's launched
if(babelHelpers.typeof(e.target.parentElement)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"HAX-STORE"===e.target.parentElement.tagName){e.target.parentElement.removeChild(e.target)}}}/**
   * Helper to convert dash to camel; important when reading attributes.
   */},{key:"dashToCamel",value:function dashToCamel(str){return str.replace(/-([a-z])/g,function(g){return g[1].toUpperCase()})}/**
   * Convert HTML into HAX Elements
   */},{key:"htmlToHaxElements",value:function htmlToHaxElements(html){var elements=[],validTags=this.validTagList,fragment=document.createElement("div");fragment.innerHTML=html;// loop over the new nodes
for(var children=fragment.childNodes,i=0;i<children.length;i++){// verify this tag is a valid one
if(babelHelpers.typeof(children[i].tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&validTags.includes(children[i].tagName.toLowerCase())){elements.push((0,_utils.nodeToHaxElement)(children[i],null))}}return elements}/**
   * Convert a node to the correct content object for saving.
   * This DOES NOT acccept a HAXElement which is similar
   */},{key:"nodeToContent",value:function nodeToContent(node){// @see haxHooks: preProcessNodeToContent
if(this.testHook(node,"preProcessNodeToContent")){node=this.runHook(node,"preProcessNodeToContent",[node])}var tag=node.tagName.toLowerCase();// support sandboxed environments which
// will hate iframe tags but love webview
if(this._isSandboxed&&"webview"===tag){tag="iframe"}var content="";// start to rebuild the same tag we got in a generalized way
content+="<"+tag;// account for things that say NOT to save slot values
// grab all of the original's attributes, and pass them to the replacement
for(var props=this.elementList[tag],propvals={},j=0,l=node.attributes.length;j<l;++j){var nodeName=node.attributes.item(j).nodeName,value=node.attributes.item(j).value;// encode objects and arrays because they are special
if("style"!=nodeName&&(babelHelpers.typeof(value)===("undefined"===typeof Object?"undefined":babelHelpers.typeof(Object))||value.constructor===Array)){propvals[nodeName]=JSON.stringify(value).replace(/"/g,"&quot;")}// only write things that aren't empty
else if(null!=value&&"null"!=value){if(!0===value||"true"===value){propvals[nodeName]=!0}else if(!1===value){// do nothing, no reason to record false unless written as text
// in which case below will capture it
}else{// ensure that value doesn't have " in it unencoded
if("string"===typeof value&&""!==value){value=value.replace(/"/g,"&quot;");propvals[nodeName]=value}// special handling for empty string cause it might mean boolean
// or it might be a string
else if(""===value){if(""==value&&""!=node.attributes.item(j).value){value=node.attributes.item(j).value}propvals[nodeName]=value}else{propvals[nodeName]=value}}}}// now look through properties
var tmpProps;// relatively cross library
if(customElements.get(tag)){tmpProps=customElements.get(tag).properties}// weak fallback
if(babelHelpers.typeof(tmpProps)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){tmpProps=node.__data}if(babelHelpers.typeof(tmpProps)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){for(var j in tmpProps){var nodeName=(0,_utils.camelToDash)(j),value=null;// prefer local value over properties object if possible
if(babelHelpers.typeof(node[j])!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){value=node[j]}// never allow read only things to recorded as they
// are run-time creation 99% of the time
// this is very polymer specific but it allows readOnly and computed props
// also __ is a popular convention for private values so let's skip them
if(!tmpProps[j].readOnly&&!tmpProps[j].computed&&value!==tmpProps[j].value&&!nodeName.startsWith("__")){// encode objects and arrays because they are special
if(null!=value&&("object"===babelHelpers.typeof(value)||value.constructor===Array)){if(value.constructor===Array&&[]!=value){propvals[nodeName]=JSON.stringify(value).replace(/"/g,"&quot;")}else if("object"===babelHelpers.typeof(value)&&{}!=value){propvals[nodeName]=JSON.stringify(value).replace(/"/g,"&quot;")}}// only write things that aren't empty
else if(null!=value&&"null"!=value){if(!0===value||"true"===value){propvals[nodeName]=!0}else if(!1===value){// do nothing, no reason to record false unless written as text
// in which case below will capture it
}else{// ensure that value doesn't have " in it unencoded
if("string"===typeof value&&""!==value){value=value.replace(/"/g,"&quot;");propvals[nodeName]=value}// special handling for empty string cause it might mean boolean
// or it might be a string
else if(""===value){if(""==value&&""!=tmpProps[j].value){value=tmpProps[j].value}else if(""===value&&""==tmpProps[j].value){// do nothing, the default value is empty
// so lets record less data
}}else{propvals[nodeName]=value}}}}}}// support for tag defining which properties NOT to save
// for simplification, everything is an attribute during this
// operation
if(babelHelpers.typeof(props)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&babelHelpers.typeof(props.saveOptions.unsetAttributes)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){for(var i in props.saveOptions.unsetAttributes){delete propvals[props.saveOptions.unsetAttributes[i]]}}// specialized clean up for some that can leak through from above
// and are edge case things because #hashtag gotta love HTML attributes
// and the webview tag. facepalm.
var delProps=["inner-text","inner-html","tabindex","guestinstance"];for(var delProp in delProps){if(babelHelpers.typeof(propvals[delProps[delProp]])!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){delete propvals[delProps[delProp]]}}// remove id attribute if it's empty, somehow misses above
if(babelHelpers.typeof(propvals.id)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&""===propvals.id){delete propvals.id}// drop these known things we never want to save
delete propvals.draggable;delete propvals.contenteditable;delete propvals["data-hax-ray"];if(""==propvals.class||"hax-active"==propvals.class){delete propvals.class}// run through the rest and print to the dom
for(var i in propvals){if(!0===propvals[i]){content+=" "+i}else{content+=" "+i+"=\""+propvals[i]+"\""}}// set the opening tag, support self-closing void tags
var voidTags=["area","base","br","col","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"];if(voidTags.includes(tag)){content+="/>"}else{content+=">"}// try and work against anything NOT a P tag
if(babelHelpers.typeof(props)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))||!props.saveOptions.wipeSlot){// get content that is in the slots
var slotnodes=node.childNodes;// ensure there's something inside of this
if(0<slotnodes.length){// loop through everything found in the slotted area and put it back in
for(var j=0,len2=slotnodes.length;j<len2;j++){if(babelHelpers.typeof(slotnodes[j].tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// if we're a custom element, keep digging, otherwise a simple
// self append is fine unless template tag cause it's a special
// case for the web in general as it'll register as not a primative
// even though it is...
if(!this.HTMLPrimativeTest(slotnodes[j].tagName)&&"TEMPLATE"!==slotnodes[j].tagName){content+=this.nodeToContent(slotnodes[j])}else{slotnodes[j].removeAttribute("data-hax-ray");slotnodes[j].contentEditable=!1;content+=slotnodes[j].outerHTML}}// keep comments with a special case since they need wrapped
else if(8===slotnodes[j].nodeType){content+="<!-- "+slotnodes[j].textContent+" -->"}// keep everything NOT an element at this point, this helps
// preserve whitespace because we're crazy about accuracy
else if(1!==slotnodes[j].nodeType&&babelHelpers.typeof(slotnodes[j].textContent)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"undefined"!==slotnodes[j].textContent){content+=slotnodes[j].textContent}}}}// @see haxHooks: progressiveEnhancement
if(this.testHook(node,"progressiveEnhancement")){content+=this.runHook(node,"progressiveEnhancement",[node])}// don't put return for span since it's an inline tag
if("span"===tag){content+="</"+tag+">"}else if("hr"===tag||"br"===tag||"img"===tag){}// do nothing for self-closing tags they'll resolve themselves
// close the tag, placing a return in output for block elements
else{content+="</"+tag+">"+"\n"}// spacing niceness for output readability
content=content.replace(/&nbsp;/gm," ");// target and remove hax specific things from output if they slipped through
content=content.replace(/ data-hax-ray="(\s|.)*?"/gim,"");content=content.replace(/ class=""/gim,"");content=content.replace(/ class="hax-active"/gim,"");content=content.replace(/ contenteditable="(\s|.)*?"/gim,"");// wipe pure style spans which can pop up on copy paste if we didn't catch it
// also ensure that we then remove purely visual chars laying around
// this also helps clean up when we did a normal contenteditable paste
// as opposed to our multi-element sanitizing option that we support
content=content.replace(/<span style="(.*?)">/gim,"<span>");content=content.replace(/<span>\s*?<\/span>/g," ");content=content.replace(/<span><br\/><\/span>/gm,"");// account for things taht on normal paste would pick up too many css vars
content=content.replace(/<strong style="(.*?)">/gim,"<strong>");content=content.replace(/<b style="(.*?)">/gim,"<b>");content=content.replace(/<strike style="(.*?)">/gim,"<strike>");content=content.replace(/<em style="(.*?)">/gim,"<em>");content=content.replace(/<i style="(.*?)">/gim,"<i>");// empty with lots of space
content=content.replace(/<p>(\s*)<\/p>/gm,"<p></p>");// empty p / more or less empty
content=content.replace(/<p>&nbsp;<\/p>/gm,"<p></p>");// br somehow getting through here
content=content.replace(/<p><br\/><\/p>/gm,"<p></p>");content=content.replace(/<p><br><\/p>/gm,"<p></p>");// whitespace in reverse of the top case now that we've cleaned it up
content=content.replace(/<\/p>(\s*)<p>/gm,"</p><p>");content=content.split("\n\r").join("\n").split("\r").join("\n").split("\n\n").join("\n").split("\n\n").join("\n").split("\n\n").join("\n");// @see haxHooks: postProcessNodeToContent
if(this.testHook(node,"postProcessNodeToContent")){content=this.runHook(node,"postProcessNodeToContent",[content])}return content}/**
   * Basic HTML Primitives test
   */},{key:"HTMLPrimativeTest",value:function HTMLPrimativeTest(node){if(babelHelpers.typeof(node.tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&-1==node.tagName.indexOf("-")){return!0}return!1}/**
   * Filter app store apps to those that accept this file source.
   */},{key:"getHaxAppStoreTargets",value:function getHaxAppStoreTargets(type){var targets=this.appList.filter(function(app){if(babelHelpers.typeof(app.connection.operations.add)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){var add=app.connection.operations.add;if(babelHelpers.typeof(add.acceptsGizmoTypes)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&add.acceptsGizmoTypes.includes(type)){return!0}}return!1});return targets}/**
   * refresh / rebuild the form based on active item
   */},{key:"refreshActiveNodeForm",value:function refreshActiveNodeForm(){this.haxTray.activeHaxElement=(0,_utils.nodeToHaxElement)(this.haxTray.activeNode,null);this.haxTray._setupForm()}/**
   * Generate Hax Element prototype.
   */},{key:"haxElementPrototype",value:function haxElementPrototype(gizmo,properties){var content=2<arguments.length&&arguments[2]!==void 0?arguments[2]:"";return{tag:gizmo.tag,properties:properties,content:content,gizmo:gizmo}}/**
   * Slot content w/ support for custom elements in slot.
   */},{key:"getHAXSlot",value:function getHAXSlot(node){// we can skip all of this if we have a text element / HTML prim!
if(this.isTextElement(node)){return node.innerHTML}var content="",slotnodes=node.childNodes;// ensure there's something inside of this
if(0<slotnodes.length){// loop through everything found in the slotted area and put it back in
for(var j=0,len2=slotnodes.length;j<len2;j++){if(babelHelpers.typeof(slotnodes[j].tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// if we're a custom element, keep digging, otherwise a simple
// self append is fine.
if(0<slotnodes[j].tagName.indexOf("-")){content+="  "+this.nodeToContent(slotnodes[j])+"\n"}else{content+="  "+slotnodes[j].outerHTML+"\n"}}// keep comments with a special case since they need wrapped
else if(8===slotnodes[j].nodeType){content+="<!-- "+slotnodes[j].textContent+" -->"}// keep everything NOT an element at this point, this helps
// preserve whitespace because we're crazy about accuracy
else if(1!==slotnodes[j].nodeType&&babelHelpers.typeof(slotnodes[j].textContent)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"undefined"!==slotnodes[j].textContent){content+=slotnodes[j].textContent}}}return content}/**
   * Notice that a property off an element was set in HAX some place; register it here
   */},{key:"_haxStoreRegisterProperties",value:function _haxStoreRegisterProperties(e){if(e.detail&&e.detail.properties&&e.detail.tag){// only register tag if we don't know about it already
if(!this.elementList[e.detail.tag]){// look for a gizmo; it's not required, technically.
var gizmo=e.detail.properties.gizmo;if(gizmo){gizmo.tag=e.detail.tag;var gizmos=this.gizmoList;gizmos.push(gizmo);this.gizmoList=babelHelpers.toConsumableArray(gizmos);this.write("gizmoList",gizmos,this);// haxHook: gizmoRegistration - allow elements to define their own
// custom functionality to run when a gizmo is registered
if(window.customElements.get(gizmo.tag)&&this.testHook(document.createElement(gizmo.tag),"gizmoRegistration")){this.runHook(document.createElement(gizmo.tag),"gizmoRegistration",[this])}}this.elementList[e.detail.tag]=e.detail.properties;// only push new values on if we got something new
if(!this.validTagList.find(function(element){return element===e.detail.tag})){this.validTagList.push(e.detail.tag)}// push to grid list IF this marks itself as a grid
if("grid"==e.detail.properties.type&&!this.validGridTagList.find(function(element){return element===e.detail.tag})){this.validGridTagList.push(e.detail.tag)}}// delete this tag if it was in the autoloader as it has served it's purpose.
if(babelHelpers.typeof(e.target.parentElement)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"HAX-AUTOLOADER"===e.target.parentElement.tagName){this.haxAutoloader.removeChild(e.target)}}}},{key:"activeGizmo",get:function get(){var gizmo=(0,_mobxEsm.toJS)(this._calculateActiveGizmo(this.activeNode));this.write("activeGizmo",gizmo,this);return gizmo}}]);return HaxStore}((0,_utils.winEventsElement)((0,_haxBodyBehaviors.HAXElement)(_litElement.LitElement)));_exports.HaxStore=HaxStore;window.customElements.define(HaxStore.tag,HaxStore);// window bridge for external projects that want to account for HAX
// yet don't want to require it as part of an import chain
window.HaxStore=window.HaxStore||{};window.HaxStore.requestAvailability=function(){if(!window.HaxStore.instance){window.HaxStore.instance=document.createElement("hax-store");document.body.appendChild(window.HaxStore.instance)}return window.HaxStore.instance};// export the singleton so everyone can directly reference it
var HAXStore=window.HaxStore.requestAvailability();// debugging / developer console shortcuts
_exports.HAXStore=HAXStore;window.Hax=window.Hax||{};window.Hax.add=function(tag){if(HAXStore.elementList[tag]){// generate schema from the tag
var schema=HAXStore.haxSchemaFromTag(tag),target;if(schema.gizmo.tag&&schema.demoSchema&&schema.demoSchema[0]){target=(0,_utils.haxElementToNode)(schema.demoSchema[0])}else{target=document.createElement(tag)}HAXStore.activeHaxBody.haxReplaceNode(HAXStore.activeNode,target);HAXStore.activeHaxBody.__focusLogic(target)}else{// do nothing, we tried to be a pro but failed :(
HAXStore.toast("".concat(tag," is not a valid tag"))}};window.Hax.delete=function(){if(null!=HAXStore.activeNode){HAXStore.activeHaxBody.haxDeleteNode(HAXStore.activeNode)}};window.Hax.duplicate=function(){HAXStore.activeHaxBody.haxDuplicateNode(HAXStore.activeNode)};window.Hax.move=function(){var dir=0<arguments.length&&arguments[0]!==void 0?arguments[0]:!0;if(dir){HAXStore.activeHaxBody.haxMoveGridPlate("up",HAXStore.activeNode)}else{HAXStore.activeHaxBody.haxMoveGridPlate("down",HAXStore.activeNode)}};window.Hax.grid=function(){var op=0<arguments.length&&arguments[0]!==void 0?arguments[0]:!0;HAXStore.activeHaxBody.haxGridPlateOps(op)};window.Hax.set=function(key,value){HAXStore.write(key,value,window)};window.Hax.get=function(key){return HAXStore[key]};window.Hax.export=function(){return HAXStore.activeHaxBody.haxToContent()};window.Hax.import=function(){var htmlContent=0<arguments.length&&arguments[0]!==void 0?arguments[0]:"<p></p>";return HAXStore.activeHaxBody.importContent(htmlContent)}});